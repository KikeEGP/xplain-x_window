<!doctype html>
<html>
<head>
    <meta charset="utf8">
    <script>
        // Hi there! Since you're looking at this, I'm sure you'd like to know a
        // bit more about the demos in this article.
        //
        // For starters, as I mention at the end of the article, the code that
        // powers all the demos in this article is at GitHub:
        //
        // https://github.com/magcius/xplain
        //
        // Most of the code that I've written is in the X server itself,
        // which can be found at src/server/server.js
        //
        // The extensive "Inspector" can be found in src/inspector/inspector.js
        //
        // The rest of the demos are clients that connect to that server, and
        // they can be found in src/article-demos/.
        //
        // The main demo "runner" framework is at src/article-demos/demos.js,
        // and the code for all the demos in the article are littered around
        // in that directory.
        //
        // I've tried to document it quite well, but if you have any more questions
        // about the code, about anything in this article, or just want to flame
        // me about Wayland or Mir, feel free to contact me through email.
        //
        // I can be reached at <jstpierre@mecheye.net>
        //
        // --
        //   Jasper
        //
        // P.S. I tried to find one of those Medium-style "margin comment"
        // systems so people could comment on this article in one place,
        // but couldn't find any hosted or open-source solutions I could
        // deploy! Disqus, other startups, please write this!
    </script>

    <link rel="stylesheet" href="article.css">
    <link rel="stylesheet" href="../src/article-demos/demos.css">
    <link rel="stylesheet" href="../src/inspector/inspector.css">
    <link rel="stylesheet" href="../src/server/server.css">
    <link rel="shortcut icon" href="favicon.png">
    <title>Xplain</title>
</head>
<body id="x-basics"><div class="main">
    <header>
        <h1><span>Xplain</span></h1>
        <span class="subtitle">Explaining X11 for the rest of us</span>
    </header>

    <article>
        <h2></h2>

        <noscript>
        <p class="warning">
            This article relies a lot of interactive demos that use JavaScript to show how the X Window System works.
            The article unfortunately won't work properly without these interactive demos, so if you feel like you're
            missing out, try enabling JavaScript?
        </p>
        </noscript>

        <section id="lets-go">
        <h3>Let's go</h3>
        <div class="demo-server demo-inspectable" data-demo="two-kittens"></div>
        <p>
            Let's start super simple. Here's a simple X server with two windows in it. They don't have any title bars,
            and you can't drag them around because I haven't launched any
            <a href="http://www.x.org/releases/current/doc/xproto/x11protocol.html#glossary:Window_manager" class="definition">window manager</a>
            yet. There's just two windows, each showing each kitten.
        </p>
        <p>
            You might notice that <span class="inspector-icon">i</span> button in the top right of the demo above.
            Click on it, and the inspector will pop open. On the left side of the inspector is a list of windows,
            and on the right side are the properties and attributes for the selected window.
        </p>
        <p>
            This lets you dig into all the demos in this article in detail, showing how things are constructed.
            So, if you ever find yourself not quite understanding something I'm saying, playing around with the
            inspector can often help.
        </p>
        <p>
            A <span class="definition">window</span>, in the X11 protocol, is a structure that allows an
            <span class="definition">X client</span> connecting to the X server to display something on the screen,
            and take input as well. Windows have a stacking order, and the top window in the stacking order
            <a href="http://www.x.org/releases/current/doc/xproto/x11protocol.html#glossary:Occlude" class="definition">occludes</a>
            other windows below it.
        </p>
        <p>
            For historical reasons related to some initial implementations, showing a window in the X11 protocol
            is called <span class="definition">mapping</span> a window, and hiding a window is called
            <span class="definition">unmapping</span>. Windows, when initially created, are unmapped (or hidden).
            Clients have to map windows they create by sending a
            <a href="http://www.x.org/releases/current/doc/xproto/x11protocol.html#requests:MapWindow">MapWindow</a>
            request to the X server. Keep in mind, unmapping a window isn't the same as destroying a window, since
            the window can be mapped again later. It's more like minimizing a window.
        </p>
        <p>
            So, we know what windows are. But how are those kittens getting on the screen?
        </p>
        </section>

        <section id="expose-model">
        <h3>Exposing historical baggage</h3>
        <p>
            In the late 80s, when the X Window System was designed, RAM was costly, and was a scarce resource.
            If we stored window contents in system memory, if you want to have a maximzed window, that would be,
            well, 1 byte * (800 * 600 pixels) =
            <a href="https://www.google.com/search?q=1%20byte%20*%20800%20*%20600%20=">almost half a megabyte!</a>
            The user can't open more than 10 maximized windows before exhausting the 5MB in his workstation, and
            with 16-bit True Color around the corner, we can't fit more than 5! No, no, this can't possibly scale.
        </p>
        <p>
            So, if we can't store window pixels in system memory, where can we store them? They have to exist
            somewhere, <em>right</em>?
        </p>
        <p>
            Nope. The trick the X Window System authors realized is that the pixels for a window don't have to exist
            at all. We only have one giant buffer of pixels for the entire screen, the
            <span class="definition">front buffer</span>, and windows borrow pixels to draw to.
        </p>
        <div class="demo-server demo-inspectable" data-demo="expose"></div>
        <p>
            The demo above shows two windows, with one window obscuring the other. The window underneath moves from
            side to side, and you can see that when it moves, the window blanks out for a moment before redrawing
            itself.
        </p>
        <p>
            The window on top, marked as <span class="code-literal">kitten1.png</span> in the inspector, owns
            a rectangle in the center of the screen. The window below, <span class="code-literal">kitten2.png</span>,
            owns a "L" shape slightly above and to the left.
        </p>
        <p>
            When the X server needs pixels from a window, it tells the window to redraw the area it's missing
            pixels for using an
            <a href="http://www.x.org/releases/current/doc/xproto/x11protocol.html#events:Expose" class="code-literal">
            Expose</a> event. The window then responds by submitting drawing commands back to the X server.
            The X server then processes all these drawing commands, touching pixels on the front buffer where the
            window is.
        </p>
        <p>
            You can also drag <span class="code-literal">kitten1.png</span> around. Try it, and see if you can figure
            out how this behaves.
            <a href="http://www.mrdoob.com/lab/javascript/effects/ie6/">Does it seem familiar?</a> The authors of
            Windows 95 chose the same design when they wrote their display server, however they called their equivalent
            to the Expose event
            <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd145213%28v=vs.85%29.aspx" class="code-literal">WM_PAINT</a>
            instead.
        </p>
        </section>

        <section id="shape">
        <h3>Windows of all shapes and sizes</h3>
        <div class="demo-server demo-inspectable" data-demo="shape"></div>
        <p>
            I said above that windows are rectangles. In the above demo, you see a circular window, so it's quite
            obvious that I lied. You can still drag the top window around, but it might slow your browser down to a
            crawl. Sorry, the math here is a lot more computationally expensive, especially in JavaScript.
        </p>
        <p>
            Internally, the X server keeps a 1-bit bitmap (think white/black pixel mask) for every window, containing
            the part of the overall rectangle that is currently showing on the screen. This data structure is called the
            <span class="definition">clip list</span> in Xorg. It's not actually a 1-bit bitmap, though, it's actually
            a data structure known as a <span class="definition">region</span>. You might recognize this if you've
            ever used the <a href="http://cairographics.org">cairo graphics library</a>, as it has an implementation
            of it in
            <a href="http://cairographics.org/manual/cairo-Regions.html" class="code-literal">cairo_region_t</a>.
        </p>
        <p>
            A region is a equivalent representation for a 1-bit bitmap: a list of rectangles. In almost of the cases
            that the X server will use a region, this representation is both more computationally-efficient and
            memory-efficient than a 1-bit bitmap. A simple exception is a checkerboard pattern (like the stipple
            background on the server above!), since there will be a lot of small, 1-pixel rectangles.
        </p>
        <p>
            If you're an old Linux user, you might remember old versions of the
            <a href="http://enlightenment.org/">Enlightenment</a> desktop environemnt having a strange way to do
            transparency by masking windows with a similar checkerboard pattern. If you turned this effect on all
            your windows, your system would start to chug a little, since the checkerboard pattern is very stressful
            on the region data structure and X server implementation.
        </p>
        <p>
            Ahem, sorry. Enough reminiscing. Anyway, the story goes that when people working on the X server source
            code were doing anything with windows, they had code that looked like this:
        </p>
        <div class="code-block">void do_something_with_window(Window window)
{
    Region region = new Region();
    region.add_rectangle(window.bounding_rectangle);

    region.intersect_rectangle(other_window.whatever);
    draw_some_nonsense(region);
}</div>
        <p>
            That is, the code was almost always taking the window's bounding rectangle, and then converting it into a
            region to use elsewhere. So, they said to themselves, <q class="historical-quote">Hey, why don't we let the
            user set any arbitrary region that will be used instead of the bounding region?</q> And thus, the
            <a href="http://www.x.org/releases/current/doc/xextproto/shape.html">X SHAPE Extension</a> was born.
        </p>
        <p>
            This is how we get a circular window, as above: we construct a region of a circle, and then set
            the window's bounding region to be that circle. This is how the classic
            <a href="http://en.wikipedia.org/wiki/Xeyes">xeyes</a> and oclock get their shapes.
        </p>
        <p>
            The inspector will show the bounding shape region of a window in yellow.
        </p>
        <p>
            There's two more notes I want to make here. Although this might seem like it would allow for some windows
            to be transparent by poking holes in them, it's an all-or-nothing proposition. That is, if you take your
            finger and point to any pixel on the above display, I can do some math and tell you the exact window that
            will paint to that pixel at any point in time. The X SHAPE Extension doesn't change this, it just makes the
            logic for figuring out which window "owns" a specific pixel more complicated than simply comparing
            rectangles. In order to allow truly transparent windows, we'll have to somehow figure out a way to blend
            between what windows draw.
        </p>
        <p>
            Also, setting a window shape larger than the window's width/height can't actually make the window own some
            pixels that it wouldn't own otherwise. Setting a window shape only allows a window to carve away from where
            it would normally paint and give that space to the windows underneath.
        </p>
        </section>

        <section id="pixmaps">
        <h3>Pixmaps</h3>
        <p>
            The nosy of you playing around with that last demo might have noticed something special on
            <span class="code-literal">kittencircle.png</span> in the last demo. In the
            <span class="inspector-section-header">Attributes</span> section of the inspector,
            you might have noticed a <span class="code-literal">background-pixmap</span> attribute, and hovering over
            it shows the circle kitten image! That raises up the question: what is a Pixmap,and why did the other
            windows have a <span class="code-literal">background-color</span> instead?
        </p>
        <p>
            You might have been wondering how it could have been efficient to keep transfering missing pixels for the
            for the kitten images at 60 frames per second. The answer is that we're not. Instead, we create a
            <span class="definition">Pixmap</span>, which allows us to have memory-backed pixel storage on the server.
            We then draw the kitten image to the Pixmap once, using
            <a href="http://www.x.org/releases/current/doc/xproto/x11protocol.html#requests:PutImage" class="code-literal">PutImage</a>.
        </p>
        <p>
            Whenever we want to draw to the window from an <span class="code-literal">Expose</span> event, we simply
            tell the X server to
            <a href="http://www.x.org/releases/current/doc/xproto/x11protocol.html#requests:CopyArea" class="code-literal">CopyArea</a>
            from the Pixmap to the Window.
        </p>
        <p>
            You might have noticed the word <span class="definition">Drawable</span> in the protocol documentation.
            A <span class="Definition">Drawable</span> is something that the user can draw to, which is either a
            Pixmap or a Window. A Pixmap draws to its own memory storage, but a Window draws to the pixels on the
            front buffer which it owns.
        </p>
        <p>
            <q>OK, so, then what's this about <span class="code-literal">background-color</span> and
            <span class="code-literal">background-pixmap</span>?</q>
        </p>
        <p>
            When the X server sends <span class="code-literal">Expose</span> events to a window, keep in mind that
            means that there are pixels "missing" from the front buffer that need to be redrawn. It needs to fill in
            the missing pixels with <em>something</em>, and the X server provides a window with three options:
        </p>
        <ol>
            <li>
                It can fill the pixels with a color. This is what the
                <span class="code-literal">background-color</span> attribute specifies.
            </li>
            <li>
                It can fill the pixels with the contents of a pixmap. This is what the
                <span class="code-literal">background-pixmap</span> attribute specifies.
            </li>
            <li>
                It can do nothing, and simply leave whatever pixels were there before, and wait for the application
                to redraw. This is also the default, and it's what you get when there's no explicit
                <span class="code-literal">background-color</span> or
                <span class="code-literal">background-pixmap</span> attributes.

                This is how Windows works, and why you see the the repeated "IE6 crashed" window when
                explorer.exe crashes.
            </li>
        </ol>
        </section>

        <section id="next-time">
        <h3>Coming up...</h3>
        <p>
            Next time, we're going to delve into more depth about windows: the window tree, window managers.
        </p>
    </article>

    <script src="article.js"></script>

    <script src="../src/pixman-region.js"></script>
    <script src="../src/pixman-region-wrapper.js"></script>
    <script src="../src/class.js"></script>
    <script src="../src/canvas-util.js"></script>
    <script src="../src/server/server.js"></script>
    <script src="../src/inspector/inspector.js"></script>
    <script src="../src/clients/toolkit.js"></script>
    <script src="../src/article-demos/demos.js"></script>
    <script src="../src/article-demos/demo-common.js"></script>
    <script src="../src/article-demos/x-basics.js"></script>

    <script>
        (function() {
            "use strict";

            window.addEventListener("load", function() {
                Article.generateNavButtons();
                Article.generateSectionLinks();
                ArticleDemos.runAllDemos();
            });
        })();
    </script>
</div></body>
</html>

<!doctype html>
<html>
<head>
    <meta charset="utf8">
    <link rel="stylesheet" href="article.css">
    <link rel="stylesheet" href="../src/inspector/inspector.css">
    <link rel="stylesheet" href="../src/server/server.css">
    <link rel="shortcut icon" href="favicon.png">
    <title>Xplain</title>
</head>
<body id="regions"><div class="main">
    <header>
        <a href="index.html">
            <h1><span>Xplain</span></h1>
            <span class="subtitle">Explaining X11 for the rest of us</span>
        </a>
    </header>

    <article>
        <h2></h2>

        <section id="prologue">
        <h3>Widening the horizon</h3>
        <p>
            While this article series is named "Xplain", and while I try to focus on concepts related to the
            X11 window system and its architecture, I often want to write about other topics, ones that are
            related, but maybe a bit more general than just X11-specific. The Regions article was an example
            of that. Today, I'm going to talk about basic software rasterization of 2D graphics. While not
            an X11-specific concept, I feel it will be interesting to the same audience, and I'll include it
            in the Xplain series. In fact, going forward, the hastily named "Xplain" will probably not be just
            about X11. If people like my "interactive demo" format for other topics, I might just rename
            the whole series to something like "Jasper's Cool Explaining Demo Articles" and talk about other
            stuff (3D graphics! Sound!). Let me know what you think.
        </p>

        <p>
            <em><strong>*cough*</strong></em>
        </p>

        <p>
            ... Excuse me. Now let's start the article, proper.
        </p>

        <p>
            Something I have been interested in for quite some time, and something I feel is not very
            widely understood, are the basics of 2D graphics and 2D graphics rasterization. I often see
            comments like "oh, if only SVG was implemented with WebGL, then it would be fast", and realize
            that people do not quite understand the challenges and complications of 2D graphics rendering.
        </p>

        <p>
            Today, we will be exploring 2D graphics by writing a software rasterizer of our own. All of the
            code was written for this article, and is open source on the GitHub repo. I've tried to comment
            it well as a source to learn from. I encourage you to study it.
        </p>
        </section>

        <section id="pixel-grid">
        <h3>The Pixel Grid</h3>
        <p>
            The X11 articles take place in a hand-written X11 server. Regional Geometry took place, well,
            in the land of geometry. Today's article takes place...
        </p> 

        <div class="demo-canvas" data-demo="rast1-demo"></div>

        <p>
            ... on the pixel grid. If you can peel your eyes away from the absolute graphical marvel I've
            created enough to read on, hopefully you (yes, you!) can learn how to create one of these of
            your very own. If not, I hope you have a better appreciation for the concepts underlying 2D
            graphics rasterization.
        </p>
        <p>
            This series will go on for multiple parts. Today, we're going to start with the basics of 2D
            graphics: the graphics buffer and its layout, abstract shapes, a basic introduction to sampling
            theory, lerping and blending colors, transparency, and end it off by adding a bit of antialiasing!
        </p>
        <p>
            A bit of note about the interactive demos on display in here today. First, I'm presenting a
            "zoomed in" buffer so you can see the pixels easier. Specifically, each "demo pixel" here
            is 16 "real pixels" wide, and the same tall. The grid itself is composed of 34 of these
            "demo pixels" horizontally, and 10 of them vertically, which are basically a few arbitrary
            constants I chose to make it fit nicely inside these margins, which are 800 "real pixels" wide.
        </p>
        <p>
            It might hurt your head to think about "demo pixels" and "real pixels". Graphics programming
            often takes place in lots of different coordinate spaces like this. After quite a long time of
            doing it, I still get confused; it's just part of the job description. If you are having trouble,
            what helps me is to just turn off the monitor, grab a pen and paper, or a whiteboard, and just
            draw the different things out.
        </p>
        <p>
            If you're serious about graphics programming, you will eventually just get so tired and confused
            that you will start peppering <code>x*8</code> and <code>(y+15)/8</code> into your code in a vain
            attempt to just get everything to match up correctly. You will start fiddling with your plus and
            minus signs, wildly reversing your translations and rotations at random in a desperate attempt
            to get things to just line up, dammit. You might find yourself even getting close, but later on,
            finding that it breaks something else. It's OK, and we've all been there. Just take a break,
            come back, and try to figure out what's really going on.
        </p>
        <p>
            To prevent any confusion like this, let's start at the beginning.
        </p>
        </section>

        <section id="coordinates">
        <h3>Coordinates</h3>
        <p>
            While I'm sure everyone here doesn't need a refresher, let's over some notation and basic math
            for how to address pixels in this grid. We often treat pixel buffers as large arrays in memory,
            and we usually leave them one-dimensional, and do the math ourselves to find a specific index
            for a given position.
        </p>
        <p>
            Buffer layouts in the real world have a lot of subtleties &mdash; whether that's stride alignment,
            endianness issues or pixel formats. If you don't know what any of those things are, don't worry,
            I'll explain them later. In this article series, we'll be using the convention established by
            HTML5's <a class="code-literal" href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData">ImageData</a>
            API. We see this pixel grid as a giant, one-dimensional array of bytes, with each pixel taking four
            bytes: red, green, blue, alpha, in that order.
        </p>

        <div class="demo-canvas" data-demo="rast1-imagedata-pixel-format"></div>

        <p>
            We can find the index of the first byte of a pixel, and vice versa, with some very simple math:
        </p>

<pre><code class="javascript">var BYTES_PER_PIXEL = 4;

function indexForPixelLocation(imageData, x, y) {
    return (y * imageData.width + x) * BYTES_PER_PIXEL;   
}

function pixelLocationForIndex(imageData, idx) {
    var pixelIdx = Math.floor(idx / BYTES_PER_PIXEL);
    var y = Math.floor(pixelIdx / imageData.width);
    var x = pixelIdx % imageData.width;
    return { x: x, y: y };
}
</code></pre>

        <p>
            Familiarize yourselves with what these functions do &mdash; they convert from the x and y
            coordinates of pixels on the grid to their index into the array of pixels. Pixels go from
             top left to bottom right, first in the X direction, then in the Y direction. The top left of
             the pixel grid is at <span class="definition">0, 0</span> at index 0. The next pixel in the
             array, which starts at index 4, is located directly to the right.
        </p>
        </section>

        <section id="draw-rectangle">
        <h3>Let's Draw a Rectangle</h3>
        <p>
            Now that we've established ourselves with the format of the pixel grid, let's try drawing
            a rectangle. For simplicity's sake, let's just fill it with black for now.
        </p>

<pre><code class="javascript">function fillPixel(imageData, x, y) {
    var idx = indexForPixelLocation(imageData, x, y);
    imageData.data[idx + 0] = 0; // Red
    imageData.data[idx + 1] = 0; // Green
    imageData.data[idx + 2] = 0; // Blue
    imageData.data[idx + 3] = 255; // Alpha
}

function fillRectangle(imageData, x1, y1, width, height) {
    for (var y = y1; y < y1 + height; y++)
        for (var x = x1; x < x1 + width; x++)
            fillPixel(imageData, x, y);
}
</code></pre>

        <p>
            And let's try it out!
        </p>

        <div class="demo-canvas" data-demo="rast1-fillrect-basic"></div>

        <p>
            This should be pretty straightforward, but there are a few pecularities I do want to go over.
            First, it may strike some of you as odd to iterate over the "y" first. It does not make any
            difference in this case, but graphics programmers often think about things in rows.
            This is a holdover from early computer graphics, and it's for performance reasons &mdash;
            if you think about the memory layout of our pixel grid, you'll notice that I'm iterating over the
            indexes in order. While RAM does stand for "random access memory", CPUs cheat and have things
            called "caches". Just know that it is cheaper to write to indexes in order than it is to jump
            around at random.
        </p>
        <p>
            While it does not matter too much in our example, you should be aware that iterating over the
            rows of a pixel grid first is common convention. This will become more apparent when we start
            going over more complex topics.
        </p>
        <p>
            It should also hopefully be pretty clear how to replace this "black" with another color, so I
            won't bother explaining that. I will, however, up the ante. Let's try filling this rectangle
            with some gradients.
        </p>
        </section>

        <section id="lerp">
        <h3>Space and Time</h3>
        <p>

            It might not seem related, but I'm going to try to explain gradients by first trying to animate
            this rectangle through time, and I'm going to do it with a technique called
            <span class="definition">linear interpolation</span>. The position in this transition is often
            called either <span class="definition">time</span> or <span class="definition">alpha</span>, but
            here we'll be using <span class="definition">time</span>, variable name <span class="code-literal">t</span>,
            to avoid confusion with the unrelated concept of the <span class="definition">alpha channel</span>.
            This <span class="code-literal">t</span> is a value between 0 and 1, which tells us which
            of the two values we should be "closer to". Let's use a "lerp" here to animate the rectangle
            across the grid.
        </p>

        <div class="demo-canvas" data-demo="rast1-fillrect-lerp"></div>
<pre><code class="javascript">function lerp(a, b, t) {
    return (a * (1.0 - t)) + (b * t);
}

function draw(imageData, secs) {
    var startX = 1;
    var endX = 38;
    var x = Math.floor(lerp(startX, endX, secs));
    var y = 1;
    fillRectangle(imageData, x, y, 8, 8);
}
</code></pre>
        <p>
            The lerp is actually a really simple and cool piece of math that can be used in a lot of
            different scenarios. I won't go into a full description,
            since <a href="https://en.wikipedia.org/wiki/Linear_interpolation">Wikipedia already has you
            mostly covered</a>, but I will show you a somewhat cool thing you can do here. The last
            parameter, "t", is a value between 0 and 1. In this case, we derive it from how many seconds have
            passed in the animation, but we can warp it a bit. We can do the obvious scaling, but we can also
            use more complicated warping. For instance, to make it slow down near the end, we can warp "t" by
            passing it through a famous easing curve known
            as "<a href="https://en.wikipedia.org/wiki/Smoothstep">smoothstep</a>":
        </p>

        <div class="demo-canvas" data-demo="rast1-fillrect-lerp-smoothstep"></div>
<pre><code class="javascript">function lerp(a, b, t) {
    return (a * (1.0 - t)) + (b * t);
}

function smoothstep(t) {
    return t*t*(3 - t*2);
}

function draw(imageData, secs) {
    var startX = 1;
    var endX = 38;
    var smoothSecs = smoothstep(secs);
    var x = Math.floor(lerp(startX, endX, smoothSecs));
    var y = 1;
    fillRectangle(imageData, x, y, 8, 8);
}
</code></pre>

        <p>
            ... which looks a bit easier on the eyes. Even though "t" stems from the word "time", as in the
            math-y "f(t)" sense of the word, it's important to realize that we can use it for more than just
            time, and we can lerp more than just the rectangle's position. For instance, we can lerp between
            two colors with just a bit more code.
        </p>
<pre><code class="javascript">function newRGB(r, g, b) {
    return { r: r, g: g, b: b };
}

function lerpRGB(color1, color2, t) {
    var newR = lerp(color1.r, color2.r, t);
    var newG = lerp(color1.g, color2.g, t);
    var newB = lerp(color1.b, color2.b, t);
    return newRGB(newR, newG, newB);
}
</code></pre>
        <p>
            This isn't doing anything more fancy than just doing a lerp across all three components in a
            color, and if we draw a ton of 1px-wide rectangles that all use this:
        </p>
<pre><code class="javascript">function fillPixel(imageData, x, y, rgb) {
    var idx = indexForPixelLocation(imageData, x, y);
    imageData.data[idx + 0] = rgb.r;
    imageData.data[idx + 1] = rgb.g;
    imageData.data[idx + 2] = rgb.b;
    imageData.data[idx + 3] = 255; // Alpha
}

function fillRectangle(imageData, rgb, x1, y1, width, height) {
    for (var y = y1; y < y1 + height; y++)
        for (var x = x1; x < x1 + width; x++)
            fillPixel(imageData, x, y, rgb);
}

function draw(imageData) {
    var startX = 1;
    var endX = 45;
    var y = 1, height = 8;

    var red = newRGB(255, 0, 0);
    var blue = newRGB(0, 0, 255);
    for (var x = startX; x < endX; x++) {
        var t = (x - startX) / (endX - startX);
        var rgb = lerpRGB(red, blue, t);
        var width = 1;
        fillRectangle(imageData, rgb, x, y, width, height);
    }
}
</code></pre>
        <div class="demo-canvas" data-demo="rast1-lerp-gradient"></div>
        <p>
            ... we end up with a smooth transition between the colors, also known as a "gradient".
        </p>
        </section>

        <section id="gradients">
        <h3>Styling our Rectangle</h3>
        <p></p>
        <div class="demo-canvas" data-demo="rast1-gradients"></div>
        <p>
            For each pixel in our rectangle, we can compute its distance to the center point, and that tells
            us how much of each color to use.
        </p>
        <p>
            Our updated code here looks like:
        </p>

<pre><code class="javascript">function newRGB(r, g, b) {
    return { r: r, g: g, b: b };
}

// Mix colors "color1" and "color2" together at time value "t",
// where 0 is "color1" and 1 is "color2".
function lerpRGB(color1, color2, t) {
    var newR = (color1.r * (1.0 - t)) + (color2.r * t);
    var newG = (color1.g * (1.0 - t)) + (color2.g * t);
    var newB = (color1.b * (1.0 - t)) + (color2.b * t);
    return newRGB(newR, newG, newB);
}

function newRadialGradient(centerX, centerY, radius, centerRGB, edgeRGB) {
    return function(x, y) {
        // Calculate distance from the center point.
        var distX = x - centerX, distY = y - centerY;
        var distance = Math.sqrt(distX*distX + distY*distY);

        // If we're outside the circle, then just return the color at the edge.
        // This is a choice -- we could instead choose to repeat or ping-pong
        // between the colors.
        if (distance >= radius)
            return edgeRGB;

        // Translate the [0, radius] ranged value to a [0, 1] ranged value
        // so we can mix the colors.
        var t = distance / radius;
        return lerpRGB(centerRGB, edgeRGB, t);
    };
}

// The same code as above, but slightly adapted to handle fill styles
// and custom colors.

function fillPixel(imageData, x, y, rgb) {
    var idx = indexForPixelLocation(imageData, x, y);
    imageData.data[idx + 0] = rgb.r;
    imageData.data[idx + 1] = rgb.g;
    imageData.data[idx + 2] = rgb.b;
    imageData.data[idx + 3] = 255; // Alpha
}

function fillRectangle(imageData, fillStyle, x1, y1, width, height) {
    for (var y = y1; y < y1 + height; y++) {
        for (var x = x1; x < x1 + width; x++) {
            var rgb = fillStyle(x, y);
            fillPixel(imageData, x, y, rgb);
        }
    }
}
</code></pre>
        <p>
            OK. There's a lot in here to go through. First off, let's go over our method of representing
            colors. Much like <span class="code-literal">ImageData</span>, we use values spanning from 0
            to 255 to represent each channel, and I put these values in an object with "r", "g", and "b"
            slots. We also need the ability to <a href="https://www.opengl.org/sdk/docs/man/html/mix.xhtml">mix</a>
            between two colors, which gives us a nice smooth transition. We can easily do this by
            <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolating</a> each of
            the two colors.
        </p>
        <p>
            After we have this ability to mix, or lerp, between two different colors, the rest of the
            algorithm is dedicated to figuring out which time "t" we should be using. In the case of a radial
            gradient, it's actually just the distance from the center point, normalized against the radius.
        </p>
        <p>
            As an exercise, try working out, using this base, how to have arbitrary gradient stops at different
            time values, rather than just two colors at the starts and ends.
        </p>
        </section>

        <section id="circles">
        <h3>Drawing Other Shapes</h3>
        <p>
            Now that we've become familiarized with the concepts of rendering boxes and fills, let's try our
            hand at something a tad bit more fancy &mdash; rendering other shapes. To start with, we'll actually
            just draw the shape we just taught ourselves how to draw above: circles. We just learned above how
            to calculate the time "t" of a point x,y against any circle, and you can visualize that a real circle
            is simply a bunch of those points where we're inside the radius. So we can just run over our pixel
            grid, test when we're "inside" the circle, and if so, choose to fill in the pixel.
        </p>
        <p>
            The only complication here is that we have to pick some start and end bounds for where we start
            iterating. We could use our <em>entire</em> pixel grid, but we know a bunch of pixels will never be
            filled in. We need a tight set of pixels. Thankfully, for a circle, it's quite easy to compute: it has
            a width of twice the radius, and "pokes out" to the left an amount of the radius.
        </p>
<pre><code class="javascript">function fillCircle(imageData, fillStyle, centerX, centerY, radius) {
    var x1 = centerX - radius, y1 = centerY - radius;
    var x2 = centerX + radius, y2 = centerY + radius;
    for (var y = y1; y < y2; y++) {
        for (var x = x1; x < x2; x++) {
            var distX = (x - centerX), distY = (y - centerY);
            var distance = Math.sqrt(distX*distX + distY*distY);
            if (distance <= radius) {
                var rgb = fillStyle(x, y);
                fillPixel(imageData, x, y, rgb);
            }
        }
    }
}
</code></pre>
        <div class="demo-canvas" data-demo="rast1-circle"></div>
        <p>
            Oof. What happened here? This doesn't look very... circular. At this point, it might be tempting
            to just try to brute force your way through the code: changing the <span class="code-literal">&lt;=</span>
            above to a single <span class="code-literal">&lt;</span>, adding various <span class="code-literal">+ 1</span>
            and <span class="code-literal">-1</span>s throughout.
        </p>
        <p>
            There is actually nothing wrong with the above code in the abstract. Instead of this being a simple
            implementation detail change, the issue with this algorithm is actually a more fundamental and
            conceptual one, one that causes us to rethink a bit about how we're viewing the pixel grid.
            You might also have spotted it above in the radial gradient example: the gradient isn't centered,
            it's sort of down and to the right. These are both related problems.
        </p>
        <p>
        </section>

        <section id="sampling">
        <h3>Sample Location</h3>
        <p>
            When we do something like the above when we draw &mdash; iterate over a bunch of pixels, and then test
            whether a pixel should be in or out, we're making use of a concept known as <span class="definition">sampling</span>.
            Basically, we have some functional concept of a shape, like a circle, and we can give it different x and y
            values and it tells us whether they are inside or outside of the circle. But what do these points mean?
        </p>
        <p>
            Well, I mean, we know that in our pixel grid, each one of these numbers corresponds to a pixel. But what
            about the <em>abstract space</em> where these circle descriptions live? We're talking about a circle
            centered at, let's say, 5, 5, with a radius of 10. We have to have some concept of mapping this abstract
            space to the pixel grid. Up until now, we haven't thought about this and have been hacking it together
            based on what makes sense. But to get this right, we need to think more closely about the relationship
            between the two.
        </p>
        <p>
            I'm going to cheat, and for my next figure, show you what this abstract space circle looks like we've been
            using so far, laid on top of the pixel grid.
        </p>
        <div class="demo-canvas" data-demo="rast1-circle-overlay"></div>
        <p>
            Maybe the revelation is clear now about what's actually going on. If not, don't worry. Right now, when
            we test each pixel against the abstract space circle, we've been testing whether the <em>top left</em>
            of the square is inside the abstract circle. When you think about it, though, that doesn't quite make sense.
            Really, what we're trying to ask is "is more than 50% of the pixel square inside the circle".
            Using something like the pixel's center would more accurately answer that question.
        </p>
        <p>
            We can do this by adjusting our <span class="code-literal">fillCircle</span> function to test distance
            against the pixel's <em>center</em> in the abstract space. Since pixel centers are halfway between pixels,
            all we need to do is add <span class="code-literal">0.5</span> to both dimensions before calculating the
            distance.
        </p>
<pre><code class="javascript">function fillCircle(imageData, fillStyle, centerX, centerY, radius) {
    var x1 = centerX - radius, y1 = centerY - radius;
    var x2 = centerX + radius, y2 = centerY + radius;
    for (var y = y1; y < y2; y++) {
        for (var x = x1; x < x2; x++) {
            var distX = (x - centerX<strong> + 0.5</strong>), distY = (y - centerY<strong> + 0.5</strong>);
            var distance = Math.sqrt(distX*distX + distY*distY);
            if (distance <= radius) {
                var rgb = fillStyle(x, y);
                fillPixel(imageData, x, y, rgb);
            }
        }
    }
}
</code></pre>
        <div class="demo-canvas" data-demo="rast1-circle-overlay-fixed"></div>
        <p>
            That looks a lot better. This also explains the bizarre gradient bug we were seeing earlier.
            When we were comparing distances in the gradients, we were also comparing distances with the
            top left of the pixel, rather than the pixel's center. I'll leave it as an exercise to the
            reader to fix that one.
        </p>
        <p>
            You might have noticed that some graphics APIs, like HTML5 &lt;canvas&gt;, require you to add
            these 0.5 increments yourselves, especially to lines, to make the resulting line look sharp.
            This is because a line is basically a "thin" rectangle which is <em>lineWidth</em> wide, and
            <em>centered</em> upon the position you give it. HTML5 &lt;canvas&gt; also uses this "pixel center"
            sampling strategy. Giving it a bit of thought (imagine a vertical rectangle "growing" in width
            from a pixel's center), and it should be obvious why this is the case.
        </p>

        <section id="transparency-and-blending">
        <h3>Transparency and Blending</h3>
        <p>
            OK, so now we have basic shapes, and basic fills. What would be really cool is to try to blend
            multiple shapes together. This is actually easier than you think, at least for a toy implementation.
            But first, the theory. As a term stolen from
            <a href="https://en.wikipedia.org/wiki/Compositing">the visual effects industry</a>, blending multiple
            transparent shapes together is formally called
            "<a href="https://en.wikipedia.org/wiki/Alpha_compositing">alpha compositing</a>", though I don't like that term very
            much, for reasons that will become clearer as the rest of the article goes on. I prefer "blending".
        </p>
        <p>
            For our toy implementation, we'll make some simplifications. Our resulting pixel grid is designed
            to be displayed directly on my monitor. Since my monitor isn't transparent (at least<a href="https://www.theverge.com/2016/1/7/10733626/panasonic-transparent-screen-display-ces-2016">not yet!</a>),
            we won't bother changing its storage, and just assume it's full opaque. However, we'll add a new
            parameter to our fill color: <span class="definition">alpha</span>, or the "A" in "RGBA".
            Alpha is commonly taken to be identical with "transparency", though this isn't fully theoretically
            accurate as we'll see later.
        </p>
        <p>
            We'll also be a bit more formal about our fill parameters. We'll call the fill pattern the
            "source image", and we'll call the pixel grid that's being filled the "destination image". To blend
            an RGBA "source image" into the opaque "destination image", instead of just setting the values like
            the old <code>fillPixel</code> did... we lerp them!
        </p>
        <pre><code class="javascript">function newRGBA(r, g, b, a) {
    return { r: r, g: g, b: b, a: a };
}

function blendPixel(imageData, x, y, rgba) {
    var idx = indexForPixelLocation(imageData, x, y);
    // Construct an RGB of the pixel grid ("destination") for our lerp.
    var data = imageData.data;
    var dst = newRGB(data[idx + 0], data[idx + 1], data[idx + 2]);
    // Lerp using the src's alpha to blend.
    var blended = mixRGB(dst, src, rgba.a);
    fillPixel(imageData, x, y, blended);
}
</code></pre>
        <div class="demo-canvas" data-demo="rast1-circle-simple-alpha"></div>
        <p>
            It's a bit clunky, but it works fine. If you think about it, it makes sense too: at 0% alpha, you
            want the untouched pixel grid (the destination), and at 100% alpha, you want the source fully filled
            in between, and at 50%, you want half of one, half of the other.
        </p>
        <p>
            This is also a simplification. To blend an RGBA image into another RGBA image,
            <a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">you have to take both alpha values into account</a> (e.g. 30% of one, 50% of the other) and the resulting image also has a new
            alpha, and the formula gets messy, and we graphics guys invented <a href="https://blogs.msdn.microsoft.com/shawnhar/2009/11/06/premultiplied-alpha/">a trick to make it faster and cleaner</a>.
            But for the simple case I gave you, I intentionally chose it to keep it nice and simple. It's a lerp!
        </p>
        </section>

        <section id="antialiasing">
        <h3>Anti-aliasing</h3>
        <p>
            So, this is looking a lot better. We have shapes, we have colors and gradients. But it still doesn't
            look great. The edges are all "jaggies", like you might see out of the Pencil tool in Photoshop
            or something made entirely in MS Paint. Looking at the zoomed in pixel grid vs. the abstract one,
            it should be obvious what the problem is: the pixel grid is much, much coarser than the abstract grid!
            In signal processing terms, we're <a href="https://en.wikipedia.org/wiki/Aliasing" class="definition">aliased</a>:
            to construct our pixel grid, we're sampling from a much <span definition="definition">higher frequency</span> space, the abstract grid,
            and that results in aliasing artifacts.
        </p>
        <p>
            ... OK. If that made no sense, here's a quick signal processing intro:
            the word "frequency" just means "how fast things change". Our abstract circle changes from "inside"
            to "outside" much "faster" than how often the grid can change, or, at a "higher frequency".
        </p>
        <p>
            Imagine a rectangle in our abstract grid that changes rapidly from black to white over and over again.
            Sampling this in our extremely course pixel grid will have a seemingly random pattern of sometimes white
            pixels and sometimes black pixels. This is known as a <a href="https://en.wikipedia.org/wiki/Moir%C3%A9_pattern" class="definition">moire pattern</a>,
            and it happens when we can't sample fast enough or fine enough for the source.
        </p>

        <p>
            Signal processing theory tells us that in order to prevent artifacts like this, we have two options:
            sample faster, or remove the high frequencies. Computer graphics implementations, conceputally, do the
            former, and <em>then</em> downsample using a special filter that blends the pixels to avoid artifacts.
        </p>

        <p>
            ... OK. That might have been a bit technical. Let's back to code. The easiest way to sample at a high
            frequency is to literally just sample more. This is an approach known as <a href="https://en.wikipedia.org/wiki/Supersampling">supersampling</a>,
            since we're sampling at a higher, or "more super", frequency. Before we do it though, we're going to need to
            refactor our code a bit and introduce a bit of infrastructure so we can sample at arbitrary points.
            The first thing we're going to do is take that if statement testing if the point is inside the circle,
            and move it out into a new function.
        </p>
        <pre><code class="javascript">function insideCircle(centerX, centerY, radius, sampleX, sampleY) {
    var distX = (sampleX - centerX), distY = (sampleY - centerY);
    var distance = Math.sqrt(distX*distX + distY*distY);
    return (distance <= radius);
}
</code></pre>
        <p>
            We also remove the "center pixel" 0.5 bias, because this will be part of our passed in sample point.
            This gives us a nice functional sampling test. Now, for each pixel, we're going to sample it 16
            different times, and collect the results. Watch closely. The code is going to be a bit hairy, but
            I'll explain it afterwards.
        </p>
        <pre><code class="javascript">function fillCircle(imageData, fillStyle, centerX, centerY, radius) {
    var numSubpixelsX = 4;
    var numSubpixelsY = 4;

    var x1 = Math.floor(centerX - radius), y1 = Math.floor(centerY - radius);
    var x2 = Math.ceil(centerX + radius), y2 = Math.ceil(centerY + radius);
    for (var y = y1; y < y2; y++) {
        for (var x = x1; x < x2; x++) {
            // Compute the coverage by sampling the circle at "subpixel"
            // locations and counting the number of subpixels turned on.
            var coverage = 0;
            for (var subpixelY = 0; subpixelY < numSubpixelsY; subpixelY++) {
                for (var subpixelX = 0; subpixelX < numSubpixelsX; subpixelX++) {
                    // Sample the center of the subpixel.
                    var sampleX = x + (subpixelX + 0.5) / numSubpixelsX;
                    var sampleY = y + (subpixelY + 0.5) / numSubpixelsY;
                    if (insideCircle(centerX, centerY, radius, sampleX, sampleY))
                        coverage += 1;
                }
            }
            coverage /= numSubpixelsX * numSubpixelsY;

            // Quick optimization: if we're fully outside the circle,
            // we don't need to compute the fill.
            if (coverage === 0)
                continue;

            var rgba = fillStyle(x, y);
            // Apply coverage to the alpha.
            rgba = newRGBA(rgba.r, rgba.g, rgba.b, rgba.a * coverage);
            blendPixel(imageData, x, y, rgba);
        }
    }
}
</code></pre>
        <div class="demo-canvas" data-demo="rast1-circle-aa"></div>
        <p>
            There's quite a lot to go through here, but the core important idea is that for each pixel,
            we're sampling the abstract grid 16 times, and then using that as an average to figure out
            "how solid" this pixel should be. In essence, we're faking a more compact pixel grid by adding
            a bit of fuzziness to the edges. There's a few more important conceptual details here: first, we
            can't represent all colors with these "fuzzed edges". We are trading color depth for the
            appearance of more space. This is why it's hard to "un-anti-alias" pictures in Photoshop if
            you've ever tried to remove a background or similar: because some of the original color was lost!
        </p>
        <p>
            Secondly, note the use of the word <span class="definition">coverage</span>, which tells
            you how much of the concrete pixel was covered by the abstract shape. Note that we also put this
            coverage value into the alpha of our source, even though it's conceptually <em>not</em> a
            transparent image. This is important: the alpha channel of an image isn't only just for
            transparency, it's also used for pixel coverage, though they do end up blending the same, and so
            we tend to combine the two into one channel.
        </p>
        <p>
            One other thing: You might notice that I'm not computing the fill style at every subsample,
            only the shape's coverage. This is an optimization known in the 3D graphics world as
            <a href="https://www.khronos.org/opengl/wiki/Multisampling">multisampling</a>. The hope is that
            the fill color of just the pixel's center really doesn't change from an average of all possible
            sample points, but the coverage does.
        </p>
        <p>
            You might also notice that the animation still seems a bit "jerky". This is because I'm drawing
            the circle locked to the pixel grid with a <code>Math.floor</code>. Now that we can represent
            arbitrary sample points thanks to proper antialiasing. Let's remove that restriction now.
        </p>
        <div class="demo-canvas" data-demo="rast1-circle-aa-smooth"></div>
        <p>
            Note the subtle additions of <code>Math.floor</code> and <code>Math.ceil</code> for when I compute
            the bounding box to help accommodate this: otherwise, the X and Y values we pass to <code>blendImage</code>
            would be fractional, and we can't really index an <code>ImageData</code> with a fractional index.
        </p>
        <p>
            Super- or multisampling are not the only approaches to doing antialasing. Another approach here is
            to use analytic methods to figure out how much area the shape actually covers. The common algorithm
            for this is commonly attributed to Raph Levien in the <a href="http://www.levien.com/libart/">libart
            rendering library</a>. I might do an interactive article for this some other day, but for now,
            I'll link to Sean Barrett, who has <a href="http://nothings.org/gamedev/rasterize/">an excellent whiteboard explanation</a>
            up on his website.
        </p>
        </section>

        <section id="next-time">
        <h3>Coming up next...</h3>
        <p>
            This was probably already a huge article to read through. Thank you for making it to the bottom! You're
            a real trooper! As always, this is only the starting point of a much deeper subject. I welcome all
            comments and questions, including ideas for additional demos to help make hard-to-understand concepts
            either. Email me, open a GitHub issue, play around with the code and see what you can make happen. The
            code for every single demo seen today is open-source, with extra comments about what's going on. It's
            also a bit more complete and refactored than what you see in the article itself. Perhaps you can take
            some inspiration from that!
        </p>
        <p>
            My plan is that next time, we'll expand on graphics further with fun things like linear transformations,
            more shapes, like complex filled polygons, bezier curves, and maybe a bit of extra fun stuff with
            perspective-textured triangles. That said, these plans aren't finalized, and if you would like me to
            cover something extra, ideas are always welcome!
        </p>
        <p>
            Thank you to everyone that left comments on the last article I made. This article has been a long time
            coming. Since my last one was written, I've made a personal decision to leave the Linux, X11, and
            Wayland worlds mostly behind. However, I'm still at a job where I interact with graphics every day,
            and I, of course, will never tire of teaching people stuff. Even if it takes me a year to actually
            finish an article. I'm hoping the expanded focus will help a lot with my motivation, though.
        </p>
        </section>

        <div class="nav-bottom"></div>
    </article>

    <script src="article.js"></script>

    <script src="../src/region.js"></script>
    <script src="../src/class.js"></script>
    <script src="../src/canvas-util.js"></script>
    <script src="../src/article-demos/demos.js"></script>
    <script src="../src/article-demos/rast1.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/railscasts.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>

    <script>
        (function() {
            "use strict";

            window.addEventListener("load", function() {
                Article.generateNavButtons();
                Article.generateSectionLinks();
                ArticleDemos.runAllDemos();
            });

            hljs.initHighlightingOnLoad();
        })();
    </script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-35480078-2', 'magcius.github.io');
      ga('send', 'pageview');
    </script>
</div></body>
</html>
